<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Phase Shift</title>
    <meta name="theme-color" content="#050505">
    <link rel="manifest" href="manifest.json">
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: 'Courier New', Courier, monospace; overflow: hidden; touch-action: manipulation; }
        
        body::after {
            content: " ";
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none; z-index: 10;
        }

        #ad-partner {
            height: 70px; width: 100%; background: #050505; 
            display: flex; align-items: center; justify-content: center;
            border-bottom: 2px solid #3300ff; box-sizing: border-box;
            padding: 10px; box-shadow: 0px 0px 20px rgba(51, 0, 255, 0.6);
            position: relative; z-index: 11;
        }
        .partner-box { width: 40px; height: 40px; border: 2px solid #00ff88; margin-right: 12px; border-radius: 2px; box-shadow: 0 0 15px #00ff88; background: #000; }
        .ad-text { font-size: 11px; letter-spacing: 2px; line-height: 1.2; text-transform: uppercase; color: #aaa; }
        .ad-text b { color: #00ff88; text-shadow: 0 0 10px #00ff88; }
        
        canvas { display: block; margin: 0 auto; filter: contrast(1.2) brightness(1.1); }
        
        #ui { position: absolute; top: 85px; width: 100%; text-align: center; pointer-events: none; z-index: 5; }
        #score { font-size: 60px; font-weight: 900; color: #fff; text-shadow: 0 0 10px #ff00ff, 0 0 30px #ff00ff; font-style: italic; }
        #best-ui { position: absolute; top: 85px; right: 20px; color: #00ff88; font-size: 12px; text-shadow: 0 0 8px #00ff88; z-index: 5; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ad-partner">
        <div class="partner-box"></div>
        <div class="ad-text">SIGNAL: <b>ENCRYPTED</b><br>[WAITING FOR SPONSOR...]</div>
    </div>

    <div id="ui"><div id="score">0</div></div>
    <div id="best-ui">BEST_RECORD: <span id="highScore">0</span></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');

        // --- ENHANCED AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, audioCtx.currentTime); 
        filter.connect(audioCtx.destination);

        let pulseSize = 0;
        let step = 0;
        const notes = [220.00, 261.63, 293.66, 329.63, 392.00]; 

        function playSynthStep() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            // 1. SMOOTH BASS
            const bass = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            bass.type = 'triangle';
            bass.frequency.setValueAtTime(55, now); 
            bassGain.gain.setValueAtTime(0, now);
            bassGain.gain.linearRampToValueAtTime(0.15, now + 0.02);
            bassGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            bass.connect(bassGain);
            bassGain.connect(filter);
            bass.start(); bass.stop(now + 0.3);

            // 2. SOFT MELODY
            if (step % 2 === 0) {
                const mel = audioCtx.createOscillator();
                const melGain = audioCtx.createGain();
                mel.type = 'sine';
                const noteIdx = (step + Math.floor(Math.random() * 2)) % notes.length;
                mel.frequency.setValueAtTime(notes[noteIdx], now);
                melGain.gain.setValueAtTime(0, now);
                melGain.gain.linearRampToValueAtTime(0.06, now + 0.01);
                melGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                mel.connect(melGain);
                melGain.connect(filter);
                mel.start(); mel.stop(now + 0.2);
            }

            // 3. SOFT DRUMS
            const drum = audioCtx.createOscillator();
            const dGain = audioCtx.createGain();
            drum.type = 'sine';
            if (step % 4 === 0) { 
                drum.frequency.setValueAtTime(80, now);
                drum.frequency.exponentialRampToValueAtTime(30, now + 0.1);
                dGain.gain.setValueAtTime(0.2, now);
            } else if (step % 4 === 2) { 
                drum.frequency.setValueAtTime(150, now);
                dGain.gain.setValueAtTime(0.05, now);
            }
            if (step % 4 === 0 || step % 4 === 2) {
                drum.connect(dGain);
                dGain.connect(filter);
                drum.start(); drum.stop(now + 0.1);
            }

            step = (step + 1) % 16;
            pulseSize = 12; 
        }

        // --- GAME LOGIC ---
        let highScore = localStorage.getItem('phaseShiftBest') || 0;
        highScoreElement.innerText = highScore;

        let laneWidth, pSize, playerY, speedBase;
        let stars = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 70;
            laneWidth = canvas.width / 2;
            pSize = Math.min(Math.max(canvas.width * 0.12, 30), 45);
            playerY = canvas.height - (pSize * 2.8);
            speedBase = canvas.height * 0.009;
            initStars();
        }

        function initStars() {
            stars = [];
            for(let i=0; i<50; i++) {
                stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, s: Math.random() * 2 });
            }
        }

        window.addEventListener('resize', resize);
        resize();

        let score = 0;
        let gameActive = true;
        let playerSide = 0; 
        let obstacles = [];
        let speed = speedBase;
        let spawnTimer = 0;
        let spawnInterval = 45; 
        let lastSide = -1;
        let sideRepeatCount = 0;

        function handleInput() {
            // 1. Force Resume
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            // 2. iOS "Silent Kickstart"
            // Create a tiny, silent beep to tell iOS the audio engine is active
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.0001, audioCtx.currentTime); // Basically silent
            osc.connect(g);
            g.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.01);

            if (!gameActive) {
                restart();
            } else {
                playerSide = playerSide === 0 ? 1 : 0;
            }
        }
        window.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(); }, {passive: false});
        window.addEventListener('mousedown', handleInput);

        function spawnObstacle() {
            if (obstacles.length > 0 && obstacles[obstacles.length-1].y < pSize * 2.5) return;
            let side = (sideRepeatCount >= 3) ? (lastSide === 0 ? 1 : 0) : (Math.random() < 0.5 ? 0 : 1);
            if (side === lastSide) sideRepeatCount++; else { sideRepeatCount = 1; lastSide = side; }
            obstacles.push({ x: side * laneWidth + (laneWidth/2 - pSize/2), y: -pSize, w: pSize, h: pSize });
        }

        function restart() {
            score = 0; scoreElement.innerText = "0";
            obstacles = []; speed = speedBase;
            spawnInterval = 45; gameActive = true;
            sideRepeatCount = 0; lastSide = -1;
            step = 0;
        }

        function update() {
            if (!gameActive) return;
            spawnTimer++;
            if (spawnTimer >= spawnInterval) { spawnObstacle(); spawnTimer = 0; }
            if (spawnTimer % 12 === 0) playSynthStep();
            pulseSize *= 0.85; 

            stars.forEach(s => {
                s.y += speed * 0.5;
                if(s.y > canvas.height) s.y = 0;
            });

            obstacles.forEach((obs, index) => {
                obs.y += speed;
                const obsSide = obs.x > laneWidth ? 1 : 0;
                if (obs.y + obs.h > playerY && obs.y < playerY + pSize && playerSide === obsSide) {
                    gameActive = false;
                }
                if (obs.y > canvas.height) {
                    obstacles.splice(index, 1);
                    score++;
                    scoreElement.innerText = score;
                    if (score > highScore) {
                        highScore = score;
                        highScoreElement.innerText = highScore;
                        localStorage.setItem('phaseShiftBest', highScore);
                    }
                    speed += (canvas.height * 0.00018); 
                    if (spawnInterval > 20) spawnInterval -= 0.25;
                }
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#fff";
            stars.forEach(s => ctx.fillRect(s.x, s.y, s.s, s.s));

            const glowIntensity = 8 + pulseSize;
            const gradient = ctx.createLinearGradient(canvas.width/2-2, 0, canvas.width/2+2, 0);
            gradient.addColorStop(0, "transparent");
            gradient.addColorStop(0.5, "#3300ff");
            gradient.addColorStop(1, "transparent");
            ctx.fillStyle = gradient;
            ctx.fillRect(canvas.width/2 - glowIntensity, 0, glowIntensity*2, canvas.height);

            const playerX = playerSide * laneWidth + (laneWidth/2 - pSize/2);
            
            ctx.shadowBlur = 15 + pulseSize; ctx.shadowColor = '#00ccff';
            ctx.fillStyle = '#fff';
            ctx.fillRect(playerX - pulseSize/4, playerY - pulseSize/4, pSize + pulseSize/2, pSize + pulseSize/2);
            ctx.strokeStyle = '#3300ff'; ctx.lineWidth = 4;
            ctx.strokeRect(playerX - pulseSize/4, playerY - pulseSize/4, pSize + pulseSize/2, pSize + pulseSize/2);

            obstacles.forEach(obs => {
                ctx.shadowBlur = 10 + pulseSize; ctx.shadowColor = '#ff00ff';
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(obs.x - pulseSize/6, obs.y - pulseSize/6, obs.w + pulseSize/3, obs.h + pulseSize/3);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                ctx.strokeRect(obs.x + 4, obs.y + 4, obs.w - 8, obs.h - 8);
            });
            ctx.shadowBlur = 0;

            if (!gameActive) {
                ctx.fillStyle = 'rgba(255, 0, 255, 0.1)';
                ctx.fillRect(Math.random()*10, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ff88';
                ctx.font = `bold ${Math.max(24, canvas.width/10)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('CRITICAL_FAILURE', canvas.width/2, canvas.height/2);
                ctx.font = '12px monospace';
                ctx.fillText('REBOOT SYSTEM: TAP TO START', canvas.width/2, canvas.height/2 + 40);
            }
            requestAnimationFrame(draw);
            update();
        }
        draw();
    </script>
</body>
</html>
