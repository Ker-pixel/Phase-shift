<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Phase Shift</title>
    <meta name="theme-color" content="#050505">
    <link rel="manifest" href="manifest.json">
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: 'Courier New', Courier, monospace; overflow: hidden; touch-action: manipulation; }
        
        body::after {
            content: " ";
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none; z-index: 10;
        }

        #ad-partner {
            height: 70px; width: 100%; background: #050505; 
            display: flex; align-items: center; justify-content: center;
            border-bottom: 2px solid #3300ff; box-sizing: border-box;
            padding: 10px; box-shadow: 0px 0px 20px rgba(51, 0, 255, 0.6);
            position: relative; z-index: 11;
        }
        .partner-box { width: 40px; height: 40px; border: 2px solid #00ff88; margin-right: 12px; border-radius: 2px; box-shadow: 0 0 15px #00ff88; background: #000; }
        .ad-text { font-size: 11px; letter-spacing: 2px; line-height: 1.2; text-transform: uppercase; color: #aaa; }
        .ad-text b { color: #00ff88; text-shadow: 0 0 10px #00ff88; }
        
        canvas { display: block; margin: 0 auto; filter: contrast(1.2) brightness(1.1); }
        
        #ui { position: absolute; top: 85px; width: 100%; text-align: center; pointer-events: none; z-index: 5; }
        #score { font-size: 60px; font-weight: 900; color: #fff; text-shadow: 0 0 10px #ff00ff, 0 0 30px #ff00ff; font-style: italic; }
        #best-ui { position: absolute; top: 85px; right: 20px; color: #00ff88; font-size: 12px; text-shadow: 0 0 8px #00ff88; z-index: 5; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ad-partner">
        <div class="partner-box"></div>
        <div class="ad-text">SIGNAL: <b>ENCRYPTED</b><br>[WAITING FOR SPONSOR...]</div>
    </div>

    <div id="ui"><div id="score">0</div></div>
    <div id="best-ui">BEST_RECORD: <span id="highScore">0</span></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');

        // --- STUDIO GRADE AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const compressor = audioCtx.createDynamicsCompressor();
        compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
        compressor.ratio.setValueAtTime(12, audioCtx.currentTime);
        compressor.connect(audioCtx.destination);

        let pulseSize = 0;
        let tick = 0;
        const chords = [
            { bass: 55.00, melody: [220, 261, 329, 392] }, // Am
            { bass: 43.65, melody: [174, 220, 261, 349] }, // F
            { bass: 49.00, melody: [196, 246, 293, 392] }, // G
            { bass: 41.20, melody: [164, 207, 246, 329] }  // E
        ];

        function playMusicTick() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;
            const chordIdx = Math.floor((tick % 64) / 16);
            const currentChord = chords[chordIdx];

            // 1. THE BEAT
            if (tick % 4 === 0) {
                const kick = audioCtx.createOscillator();
                const kG = audioCtx.createGain();
                kick.frequency.setValueAtTime(120, now);
                kick.frequency.exponentialRampToValueAtTime(0.01, now + 0.15);
                kG.gain.setValueAtTime(0.3, now);
                kG.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                kick.connect(kG); kG.connect(compressor);
                kick.start(); kick.stop(now + 0.15);
                pulseSize = 15;
            }
            
            // 2. THE BASS GALLOP
            const bass = audioCtx.createOscillator();
            const bG = audioCtx.createGain();
            const bF = audioCtx.createBiquadFilter();
            bass.type = 'sawtooth';
            bass.frequency.setValueAtTime(currentChord.bass, now);
            bF.type = 'lowpass'; bF.frequency.setValueAtTime(150, now);
            bG.gain.setValueAtTime(0, now);
            bG.gain.linearRampToValueAtTime(0.12, now + 0.01);
            bG.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            bass.connect(bF); bF.connect(bG); bG.connect(compressor);
            bass.start(); bass.stop(now + 0.1);

            // 3. SHIMMERING ARPEGGIO
            if (tick % 2 === 0) {
                const arp = audioCtx.createOscillator();
                const aG = audioCtx.createGain();
                arp.type = 'triangle';
                arp.frequency.setValueAtTime(currentChord.melody[tick % 4] * 2, now);
                aG.gain.setValueAtTime(0, now);
                aG.gain.linearRampToValueAtTime(0.04, now + 0.01);
                aG.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                arp.connect(aG); aG.connect(compressor);
                arp.start(); arp.stop(now + 0.3);
            }
            tick++;
        }

        let highScore = localStorage.getItem('phaseShiftBest') || 0;
        highScoreElement.innerText = highScore;
        let laneWidth, pSize, playerY, speedBase, stars = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 70;
            laneWidth = canvas.width / 2;
            pSize = Math.min(Math.max(canvas.width * 0.12, 30), 45);
            playerY = canvas.height - (pSize * 2.8);
            speedBase = canvas.height * 0.009;
            initStars();
        }

        function initStars() {
            stars = [];
            for(let i=0; i<50; i++) stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, s: Math.random() * 2 });
        }

        window.addEventListener('resize', resize);
        resize();

        let score = 0, gameActive = true, playerSide = 0, obstacles = [], speed = speedBase;
        let spawnTimer = 0, spawnInterval = 45, lastSide = -1, sideRepeatCount = 0;

        function handleInput() {
            // iOS Audio Unlock Logic
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const source = audioCtx.createBufferSource();
            source.buffer = audioCtx.createBuffer(1, 1, 22050);
            source.connect(audioCtx.destination);
            source.start();

            if (!gameActive) restart();
            else playerSide = playerSide === 0 ? 1 : 0;
        }
        
        window.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(); }, {passive: false});
        window.addEventListener('mousedown', (e) => { handleInput(); });

        function spawnObstacle() {
            if (obstacles.length > 0 && obstacles[obstacles.length-1].y < pSize * 2.5) return;
            let side = (sideRepeatCount >= 3) ? (lastSide === 0 ? 1 : 0) : (Math.random() < 0.5 ? 0 : 1);
            if (side === lastSide) sideRepeatCount++; else { sideRepeatCount = 1; lastSide = side; }
            obstacles.push({ x: side * laneWidth + (laneWidth/2 - pSize/2), y: -pSize, w: pSize, h: pSize });
        }

        function restart() {
            score = 0; scoreElement.innerText = "0";
            obstacles = []; speed = speedBase;
            spawnInterval = 45; gameActive = true;
            tick = 0;
        }

        function update() {
            if (!gameActive) return;
            spawnTimer++;
            if (spawnTimer >= spawnInterval) { spawnObstacle(); spawnTimer = 0; }
            if (spawnTimer % 12 === 0) playMusicTick();
            pulseSize *= 0.85; 

            stars.forEach(s => {
                s.y += speed * 0.5;
                if(s.y > canvas.height) s.y = 0;
            });

            obstacles.forEach((obs, index) => {
                obs.y += speed;
                if (obs.y + obs.h > playerY && obs.y < playerY + pSize && playerSide === (obs.x > laneWidth ? 1 : 0)) {
                    gameActive = false;
                }
                if (obs.y > canvas.height) {
                    obstacles.splice(index, 1);
                    score++;
                    scoreElement.innerText = score;
                    if (score > highScore) {
                        highScore = score;
                        highScoreElement.innerText = highScore;
                        localStorage.setItem('phaseShiftBest', highScore);
                    }
                    speed += (canvas.height * 0.00018); 
                    if (spawnInterval > 20) spawnInterval -= 0.25;
                }
            });
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#fff";
            stars.forEach(s => ctx.fillRect(s.x, s.y, s.s, s.s));

            const glowIntensity = 8 + pulseSize;
            const gradient = ctx.createLinearGradient(canvas.width/2-2, 0, canvas.width/2+2, 0);
            gradient.addColorStop(0, "transparent");
            gradient.addColorStop(0.5, "#3300ff");
            gradient.addColorStop(1, "transparent");
            ctx.fillStyle = gradient;
            ctx.fillRect(canvas.width/2 - glowIntensity, 0, glowIntensity*2, canvas.height);

            const playerX = playerSide * laneWidth + (laneWidth/2 - pSize/2);
            ctx.shadowBlur = 15 + pulseSize; ctx.shadowColor = '#00ccff';
            ctx.fillStyle = '#fff';
            ctx.fillRect(playerX - pulseSize/4, playerY - pulseSize/4, pSize + pulseSize/2, pSize + pulseSize/2);
            
            obstacles.forEach(obs => {
                ctx.shadowBlur = 10 + pulseSize; ctx.shadowColor = '#ff00ff';
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(obs.x - pulseSize/6, obs.y - pulseSize/6, obs.w + pulseSize/3, obs.h + pulseSize/3);
            });
            ctx.shadowBlur = 0;

            if (!gameActive) {
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ff88';
                ctx.font = `bold ${Math.max(24, canvas.width/10)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('CRITICAL_FAILURE', canvas.width/2, canvas.height/2);
                ctx.font = '12px monospace';
                ctx.fillText('REBOOT SYSTEM: TAP TO START', canvas.width/2, canvas.height/2 + 40);
            }
            requestAnimationFrame(draw);
            update();
        }
        draw();
    </script>
</body>
</html>
